\documentclass{scrartcl}

% configuration lifted from chez-sty at https://github.com/chezbgone/chez-sty
\KOMAoptions{paper=letter, fontsize=10pt, usegeometry}

% standard
\usepackage{mathtools, amssymb, amsthm}
\usepackage[shortlabels, inline]{enumitem}

% layout
\usepackage[margin=1.5cm, includefoot]{geometry}
\usepackage[nodisplayskipstretch, onehalfspacing]{setspace}
% section numbers in margin
\RenewDocumentCommand{\sectionlinesformat}{m m m m}{\makebox[0pt][r]{#3}#4}

% typography
\usepackage{libertine, microtype}
\usepackage[shortlabels, inline]{enumitem}

% smaller title style
\makeatletter \patchcmd{\@maketitle}{\huge}{\large}{}{} \makeatother
\setkomafont{author}{\normalsize\scshape}
\setkomafont{date}{\normalsize}
\RedeclareSectionCommand[beforeskip=0.4\baselineskip]{paragraph}

% % % % % % % % % % % % % % % % % % % % %
% actual content

\title{Schedgehog: a property-based testing library}
\author{Jason Chen \and CJ Quines \and Matthew Ho}

\begin{document}
\maketitle

\section{Overview}

In software engineering, testing code is considered to be a vital part of
delivering quality software. However, writing unit tests is extremely time
consuming, and it is easy for the programmer to miss certain cases for more
complicated functions. Therefore, it is desirable to try to automate this
processes either partially, or entirely.

We present a tool called \textbf{Schedgehog}, based on existing Haskell work
like QuickCheck \cite{quickcheck} or Hedgehog \cite{hedgehog}, that allows
users to formulate properties of programs and then automatically runs tests
based on the properties. Properties that users want to test will be specified
via a DSL embedded in Scheme; these are represented as functions along with
typing information.

Test data is generated based on this typing information. Schedgehog's generators
are generic functions that satisfy two main properties:

\begin{itemize}
\item \textit{generator derivation}, which allows automatically generating new
types by using combinators over existing generators, and,
\item \textit{test shrinking}, which allows automatically simplifying failing
counterexamples, via a built-in user-extensible rule-based system.
\end{itemize}

\section{Basic usage}

Properties are specified with the macro \verb|forall|. Properties are functions
with typed arguments that return a boolean.

\begin{verbatim}
(define prop:addition-commutativity
  (forall ((x integer) (y integer))
          (= (+ x y) (+ y x))))
\end{verbatim}

Primitive types include \verb|integer|, \verb|boolean|, and \verb|float|. A full
list of built-in primitive types are in \verb|src/generator-instances.scm|.
There are also dependent types, like \verb|linear| or \verb|range|, that take
in other arguments.

\begin{verbatim}
(define prop:addition-bounds
  (forall ((x (range 10 30)) (y (range 10 30)))
          (< 20 (+ x y) 60)))
\end{verbatim}

These types can be combined with type constructors to produce more complex
types. Some examples of type constructors include \verb|pair| and \verb|list|.

\begin{verbatim}
(define prop:sum-linear
  (forall ((xs (list integer)) (factor integer))
          (equal? (* factor (apply + xs))
                  (apply + (map (lambda (x) (* factor x)) xs)))))
\end{verbatim}

The main interface for checking a property is with the function \verb|check|.
This runs the function against several random test cases. It then prints
the result of the test, along with a counterexample if found.

\begin{verbatim}
(check prop:addition-commutativity)
; seed: ...
; ok 100 tests
(check prop:addition-bounds)
; seed: ...
; failed after 82 tests, 0 shrinks:
; ((x 10) (y 10))
\end{verbatim}

The function \verb|check-with-config| allows checking a property with a custom
configuration (which contains the maximum number of shrinks and tests to run),
size (which determines the size of generated inputs), and seed.

\begin{verbatim}
(check-with-config
  (make-config 1000 1000)
  1000
  (make-random-state #t)
  prop:addition-commutativity)
; ok 1000 tests
\end{verbatim}

\section{Generators}

The file \verb|examples/generator.scm| contains extensive examples of the
library of built-in generators.

A generator represents a source of values for randomly checking a property.
Intuitively, it can be thought of as a structure containing two components:
\begin{itemize}
\item A generating function \verb|size -> seed -> value|
\item A shrinking function \verb|value -> list value|
\end{itemize}
A generating function alone is not a generator object, for a generator object
must return a lazy tree of values. To create a generator without dealing with
lazy tree internals, we would need to call library functions.

Suppose one had a generating function \verb|gen|. The simplest way to make a
generator would be to call \verb|(no-shrink gen)|, which returns a generator
object that does not have a shrinker.

\begin{verb}
(define gen-1 (no-shrink (lambda (size seed) 1)))
(print-lazy-tree (generate gen-1))
\end{verb}

We can reigster a generator with a type by calling \verb|set-generator!|. This
allows it to be called with \verb|arbitrary|, a generic function.

\begin{verb}
(set-generator! 'type-1 gen-1)
(print-lazy-tree (generate (arbitrary 'type-1)))
(check (forall (x type-1) (= x 1)))
\end{verb}

To replace the shrink function of a generator with a specified shrink function
\verb|shrink|, we call \verb|replace-shrink-tree shrink| with the generator.

\begin{verb}
(define (shrink-fn value) (case value ((1) (list 0)) ((0) (list))))
(define gen-2 ((replace-shrink-tree shrink-fn) gen-1))
(print-lazy-tree (generate gen-2))
\end{verb}

We can also create parametrized generators. The function \verb|arbitrary|, when
given a list of symbols, will instead search for a handler for the first symbol,
to be called on the list of the remaining symbols as arguments, expecting a
generator returned.

\begin{verb}
(define (gen-constant val) (no-shrink (lambda (size seed) val)))
(set-generator! 'type-constant (lambda (val) (gen-constant val)))
(print-lazy-tree (generate (arbitrary ('type-constant 1))))
\end{verb}

Note that the type of generators forms a monad. The monad methods are in the
library as \verb|gen:pure| and \verb|gen:bind|; we also provide convenience
functions \verb|gen:map|, \verb|gen:apply|, \verb|gen:list|, etc.

\section{Shrinkers}

% talk about shrinkers
% talk about the lazy tree and how implementation can be swapped

\section{Combinators}

% talk about combinators

\section{Extensions}

% idk

\begin{thebibliography}{99}

\bibitem{quickcheck}
Claessen, K., \& Hughes, J. (2011). QuickCheck: a lightweight tool for random
testing of Haskell programs. \textit{ACM SigPlan Notices}, 46(4), 53-64.

\bibitem{hedgehog}
Hedgehog QA. (2019). Hedgehog will eat all your bugs. Retrieved from
\url{https://hedgehog.qa/}.

\end{thebibliography}

\end{document}
